name: "Merge Queue Status Check"
description: "Determines if checks should run in a merge queue based on PR status and base SHA changes"
author: "nf-neuro team"

inputs:
  token:
    description: "GitHub token for API access"
    required: true
    default: ${{ github.token }}
  merge-group-event:
    description: "The complete merge_group event payload as JSON"
    required: true
  pr-workflow-path:
    description: "Path to the PR workflow file (e.g., .github/workflows/update_pr.yml)"
    required: false
    default: ".github/workflows/update_pr.yml"
  checks-job-name:
    description: "Name of the checks job to monitor"
    required: false
    default: "checks / status"

outputs:
  should-run-checks:
    description: "Whether checks should be run (true/false)"
    value: ${{ steps.determine.outputs.should_run_checks }}
  reason:
    description: "Reason for the decision"
    value: ${{ steps.determine.outputs.reason }}

runs:
  using: "composite"
  steps:
    - name: Extract PR number from merge group
      id: extract-pr-number
      shell: bash
      run: |
        # Extract PR number from the head_ref (format: refs/pull/123/merge)
        MERGE_GROUP_EVENT='${{ inputs.merge-group-event }}'
        HEAD_REF=$(echo "$MERGE_GROUP_EVENT" | jq -r '.head_ref')
        PR_NUMBER=$(echo "$HEAD_REF" | sed -n 's|^refs/pull/\([0-9]*\)/.*|\1|p')
        echo "pr_number=$PR_NUMBER" >> $GITHUB_OUTPUT

    - name: Check merge queue conditions
      id: check
      uses: actions/github-script@v7
      with:
        github-token: ${{ inputs.token }}
        script: |
          const prNumber = '${{ steps.extract-pr-number.outputs.pr_number }}';
          const prWorkflowPath = '${{ inputs.pr-workflow-path }}';
          const checksJobName = '${{ inputs.checks-job-name }}';

          if (!prNumber) {
            return { shouldRun: true, reason: 'Unable to extract PR number' };
          }

          try {
            // Get PR details
            const { data: pr } = await github.rest.pulls.get({
              owner: 'scilus',
              repo: 'nf-neuro',
              pull_number: prNumber
            });

            // Check if last event on the PR is synchronisation by the merge queue
            const { data: events } = await github.rest.issues.listEventsForTimeline({
              owner: 'scilus',
              repo: 'nf-neuro',
              issue_number: prNumber,
              per_page: 50
            });

            const sortedEvents = events.sort(
              (a, b) => new Date(b.created_at).getTime() - new Date(a.created_at).getTime()
            );

            const queueUpdatedPr = sortedEvents.length > 0 && (
              sortedEvents[0].event === 'head_ref_force_pushed' ||
              sortedEvents[0].event === 'synchronize'
            ) && sortedEvents[0].actor.login === 'github-merge-queue[bot]';

            // Check if the latest workflow run for the PR had a failed/cancelled checks job
            const { data: workflowRuns } = await github.rest.actions.listWorkflowRunsForRepo({
              owner: 'scilus',
              repo: 'nf-neuro',
              per_page: 100
            });

            const relevantRuns = workflowRuns.workflow_runs.filter(run => {
              return run.path === prWorkflowPath &&
                    run.pull_requests &&
                    run.pull_requests.some(pr => pr.number == prNumber);
            }).sort((a, b) => new Date(b.created_at).getTime() - new Date(a.created_at).getTime());

            let hasFailedChecksJob = false;
            let checksJobStatus = 'not_found';

            if (relevantRuns.length > 0) {
              const latestRun = relevantRuns[0];

              const { data: jobs } = await github.rest.actions.listJobsForWorkflowRun({
                owner: 'scilus',
                repo: 'nf-neuro',
                run_id: latestRun.id
              });

              const checksJob = jobs.jobs.find(job => job.name === checksJobName);

              if (checksJob) {
                checksJobStatus = checksJob.conclusion || checksJob.status;
                hasFailedChecksJob = checksJob.conclusion === 'failure' ||
                                    checksJob.conclusion === 'cancelled' ||
                                    checksJob.conclusion === 'timed_out';
              } else {
                hasFailedChecksJob = true;
                checksJobStatus = 'not_found';
              }
            } else {
              hasFailedChecksJob = true;
            }

            const shouldRun = queueUpdatedPr || hasFailedChecksJob;

            let reason = [];
            if (queueUpdatedPr) {
              reason.push('most recent PR event was from merge queue bot');
            } else if (hasFailedChecksJob && checksJobStatus === 'not_found') {
              reason.push(`${checksJobName} job not found in latest run of ${prWorkflowPath}`);
            } else if (hasFailedChecksJob && checksJobStatus !== 'not_found') {
              reason.push(`${checksJobName} job ${checksJobStatus} in latest run of ${prWorkflowPath}`);
            } else {
              reason.push(`${checksJobName} job passed and no recent merge queue activity`);
            }

            return {
              shouldRun,
              reason: reason.join(', ')
            };

          } catch (error) {
            return { shouldRun: true, reason: `API error: ${error}` };
          }

    - name: Set outputs
      id: determine
      shell: bash
      run: |
        RESULT='${{ steps.check.outputs.result }}'
        SHOULD_RUN=$(echo "$RESULT" | jq -r '.shouldRun')
        REASON=$(echo "$RESULT" | jq -r '.reason')

        echo "should_run_checks=$SHOULD_RUN" >> $GITHUB_OUTPUT
        echo "reason=$REASON" >> $GITHUB_OUTPUT

        if [[ "$SHOULD_RUN" == "true" ]]; then
          echo "✅ Should run checks: $REASON"
        else
          echo "⏭️ Should skip checks: $REASON"
        fi

branding:
  icon: "git-merge"
  color: "blue"
