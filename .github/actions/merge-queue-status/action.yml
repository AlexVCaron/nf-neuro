name: "Merge Queue Status Check"
description: "Determines if checks should run in a merge queue based on PR status and base SHA changes"
author: "nf-neuro team"

inputs:
  token:
    description: "GitHub token for API access"
    required: true
    default: ${{ github.token }}
  merge-group-event:
    description: "The complete merge_group event payload as JSON"
    required: true
  pr-workflow-path:
    description: "Path to the PR workflow file (e.g., .github/workflows/update_pr.yml)"
    required: false
    default: ".github/workflows/update_pr.yml"
  checks-job-name:
    description: "Name of the checks job to monitor"
    required: false
    default: "checks"

outputs:
  should-run-checks:
    description: "Whether checks should be run (true/false)"
    value: ${{ steps.determine.outputs.should_run_checks }}
  reason:
    description: "Reason for the decision"
    value: ${{ steps.determine.outputs.reason }}

runs:
  using: "composite"
  steps:
    - name: Extract PR number from merge group
      id: extract
      shell: bash
      run: |
        # Extract PR number from the head_ref (format: refs/pull/123/merge)
        MERGE_GROUP_EVENT='${{ inputs.merge-group-event }}'
        HEAD_REF=$(echo "$MERGE_GROUP_EVENT" | jq -r '.head_ref')
        PR_NUMBER=$(echo "$HEAD_REF" | sed -n 's|^refs/pull/\([0-9]*\)/.*|\1|p')
        echo "pr_number=$PR_NUMBER" >> $GITHUB_OUTPUT

    - name: Check merge queue conditions
      id: check
      uses: actions/github-script@v7
      with:
        github-token: ${{ inputs.token }}
        script: |
          const mergeGroupEvent = JSON.parse(`${{ inputs.merge-group-event }}`);
          const prNumber = '${{ steps.extract.outputs.pr_number }}';
          const mergeGroupBaseSha = mergeGroupEvent.base_sha;
          const prWorkflowPath = '${{ inputs.pr-workflow-path }}';
          const checksJobName = '${{ inputs.checks-job-name }}';

          if (!prNumber) {
            return { shouldRun: true, reason: 'Unable to extract PR number' };
          }

          try {
            // Get PR details
            const { data: pr } = await github.rest.pulls.get({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: prNumber
            });

            // Check if merge queue updated the PR (base SHA changed)
            const originalBaseSha = pr.base.sha;
            const queueUpdatedPr = mergeGroupBaseSha !== originalBaseSha;

            // Get the latest workflow runs for the PR head SHA
            const { data: workflowRuns } = await github.rest.actions.listWorkflowRunsForRepo({
              owner: context.repo.owner,
              repo: context.repo.repo,
              head_sha: pr.head.sha,
              per_page: 100
            });

            // Find the most recent PR workflow run by path
            const prRuns = workflowRuns.workflow_runs.filter(run =>
              run.path === prWorkflowPath
            ).sort((a, b) => new Date(b.created_at) - new Date(a.created_at));

            let hasFailedChecksJob = false;
            let checksJobStatus = 'not_found';

            if (prRuns.length > 0) {
              const latestRun = prRuns[0];

              const { data: jobs } = await github.rest.actions.listJobsForWorkflowRun({
                owner: context.repo.owner,
                repo: context.repo.repo,
                run_id: latestRun.id
              });

              const checksJob = jobs.jobs.find(job => job.name === checksJobName);

              if (checksJob) {
                checksJobStatus = checksJob.conclusion || checksJob.status;
                hasFailedChecksJob = checksJob.conclusion === 'failure' ||
                                    checksJob.conclusion === 'cancelled' ||
                                    checksJob.conclusion === 'timed_out';
              } else {
                hasFailedChecksJob = true;
                checksJobStatus = 'not_found';
              }
            } else {
              hasFailedChecksJob = true;
            }

            const shouldRun = queueUpdatedPr || hasFailedChecksJob;

            let reason = [];
            if (queueUpdatedPr) reason.push('merge queue updated PR base');
            if (hasFailedChecksJob && checksJobStatus === 'not_found') reason.push(`${checksJobName} job not found in latest run of ${prWorkflowPath}`);
            if (hasFailedChecksJob && checksJobStatus !== 'not_found') reason.push(`${checksJobName} job ${checksJobStatus} in latest run of ${prWorkflowPath}`);
            if (reason.length === 0) reason.push(`${checksJobName} job passed and no queue updates`);

            return {
              shouldRun,
              reason: reason.join(', ')
            };

          } catch (error) {
            return { shouldRun: true, reason: `API error: ${error.message}` };
          }

    - name: Set outputs
      id: determine
      shell: bash
      run: |
        RESULT='${{ steps.check.outputs.result }}'
        SHOULD_RUN=$(echo "$RESULT" | jq -r '.shouldRun')
        REASON=$(echo "$RESULT" | jq -r '.reason')

        echo "should_run_checks=$SHOULD_RUN" >> $GITHUB_OUTPUT
        echo "reason=$REASON" >> $GITHUB_OUTPUT

        if [[ "$SHOULD_RUN" == "true" ]]; then
          echo "✅ Should run checks: $REASON"
        else
          echo "⏭️ Should skip checks: $REASON"
        fi

branding:
  icon: "git-merge"
  color: "blue"
